import type {
  PaymentOrderDTO,
  ProductDTO,
  FeeDTO,
  CreateOrderData,
  ApiGridResponse,
} from "../types";
import { ORDER_STATUS } from "../utils";
import { apiFetch } from "./apiService";

// Mock data
const mockOrders: PaymentOrderDTO[] = [
  {
    id: "1",
    amount: 229.98,
    paymentMethod: "Credit Card",
    providerName: "PayPal",
    providerOrderId: "PP-12345",
    orderStatus: ORDER_STATUS.PAID,
    fees: [
      { name: "Processing Fee", amount: 5.99 },
      { name: "Service Fee", amount: 2.5 },
    ],
    products: [
      {
        id: "1",
        name: "Wireless Headphones",
        unitPrice: 199.99,
        isActive: true,
        unitsInStock: 25,
      },
      {
        id: "2",
        name: "Smartphone Case",
        unitPrice: 29.99,
        isActive: true,
        unitsInStock: 100,
      },
    ],
  },
  {
    id: "2",
    amount: 92.98,
    paymentMethod: "Debit Card",
    providerName: "PayPal",
    providerOrderId: "PP-12345",
    orderStatus: ORDER_STATUS.PENDING,
    fees: [],
    products: [
      {
        id: "3",
        name: "USB Cable",
        unitPrice: 12.99,
        isActive: true,
        unitsInStock: 50,
      },
      {
        id: "4",
        name: "Bluetooth Speaker",
        unitPrice: 79.99,
        isActive: false,
        unitsInStock: 0,
      },
    ],
  },
];

const delay = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

export class OrderService {
  private static orders: PaymentOrderDTO[];

  static async getAllOrders(): Promise<PaymentOrderDTO[]> {
    const response = await apiFetch<ApiGridResponse<PaymentOrderDTO[]>>(
      "paymentOrders"
    );
    this.orders = response.data;
    return response.data;
    return [...this.orders];
  }

  static async getOrderById(id: string): Promise<PaymentOrderDTO | null> {
    return apiFetch<PaymentOrderDTO>(`/paymentOrders/id=${id}`);
  }

  static async createOrder(
    products: ProductDTO[],
    orderData: CreateOrderData
  ): Promise<PaymentOrderDTO> {
    let data: PaymentOrderDTO = {
      id: "3fa85f64-5717-4562-b3fc-2c963f66afa6", // This would be generated by the backend
      amount: 0,
      paymentMethod: orderData.paymentMethod,
      orderStatus: ORDER_STATUS.PENDING,
      fees: [],
      products: products,
    };
    const newOrder = await apiFetch<PaymentOrderDTO>("paymentOrders", {
      method: "POST",
      body: JSON.stringify(data),
    });
    this.orders.push(newOrder);
    return newOrder;
  }

  static async updateOrderStatus(
    id: string,
    newStatus: string
  ): Promise<PaymentOrderDTO> {
    await delay(500);

    const index = this.orders.findIndex((orders) => orders.id === id);
    if (index === -1) {
      throw new Error("Product not found");
    }

    if (newStatus === ORDER_STATUS.PAID) {
      await apiFetch(`paymentOrders/pay`, {
        method: "PUT",
        body: JSON.stringify(id),
      });
    }
    if (newStatus === ORDER_STATUS.CANCELLED) {
      await apiFetch(`paymentOrders/cancel`, {
        method: "PUT",
        body: JSON.stringify(id),
      });
    }
    this.orders[index].orderStatus = newStatus;
    return this.orders[index];
  }

  static async getOrdersByProductId(
    productId: string
  ): Promise<PaymentOrderDTO[]> {
    const orders = this.orders.filter((order) =>
      order.products.some((product) => product.id === productId)
    );
    return orders;
  }

  static async deleteOrder(id: string): Promise<void> {
    const index = this.orders.findIndex((order) => order.id === id);
    if (index === -1) {
      throw new Error("Order not found");
    }
    const response = await apiFetch(`paymentOrders?id=${id}`, {
      method: "DELETE",
    });

    this.orders.splice(index, 1);
  }

  static async getOrdersByStatus(status: string): Promise<PaymentOrderDTO[]> {
    return this.orders.filter((order) => order.orderStatus === status);
  }

  static async cancelOrder(id: string): Promise<PaymentOrderDTO> {
    return this.updateOrderStatus(id, ORDER_STATUS.CANCELLED);
  }

  static async payOrder(id: string): Promise<PaymentOrderDTO> {
    return this.updateOrderStatus(id, ORDER_STATUS.PAID);
  }

  static async getOrderStatistics(): Promise<{
    total: number;
    paid: number;
    pending: number;
    cancelled: number;
  }> {
    return {
      total: this.orders.length,
      paid: this.orders.filter((o) => o.orderStatus === ORDER_STATUS.PAID)
        .length,
      pending: this.orders.filter((o) => o.orderStatus === ORDER_STATUS.PENDING)
        .length,
      cancelled: this.orders.filter(
        (o) => o.orderStatus === ORDER_STATUS.CANCELLED
      ).length,
    };
  }
}
